## 问题

![question](http://o9dp8fd6w.bkt.clouddn.com/markdown/180426/h4aJg8Ie5h.png?imageslim)

**问题**：

1. **求当 n ＝ 20，m ＝ 3 时的最少切分次数。**
2. **求当 n ＝ 100，m ＝ 5 时的最少切分次数。**



## 主要思路 

- 当前木棒数量和总人数`m`共同决定了当前的最多切割次数。当目前的木棒数量小于`m`时，那么当前最大的切割数为当前木棒数量；反之则为`m`！

- 由于最终都是要切成长度为`1`的木棒，所以可以每次切割都从长度最长的木棒切出一块长度为`1`的木棒，因此木棒长度就只剩下大于`1`和等于`1`两种情况；在这种情况下，就可以把切割长度忽略，只看切割次数。

  ```js
  function for_question1(n, m) {
      let woodN = 1; // 当前木棒的数量，初始时只有一根
      let num = 0; // 切割的轮次

      while(woodN < n){
          if(woodN > m){ // 根据当前木棒的数量与人数的关系，来判断切割的次数
              woodN += m; // 切割多少次，木棒的数量则相应增加多少次
          }else{
              woodN += woodN;
          }
          num++;
      }

      console.log(num);
  }
  ```

  ​

- 也可以把这个问题等价为：有`n`根长度为`1`的木棒，要合并成一根长度为`n`的木棒。每次合并的最大次数也是与当前木棒数以及`m`有关，因为一次合并对应一次分割，所以每一次合并都需要两根不同的木棒，假设当前木棒数为`x`，那么如果`x/2`大于`m`则最大合并次数为`m`，反之为`x/2`（向下取整）。

  ```js
  function for_question2(n, m){ // 逆向合并木棒
      let num = 0; // 合并轮次数
      let woodN = n; // 当前木棒数，初始时为n根木棒

      while(woodN > 1){
          if(woodN / 2 > m){ // 根据目前木棒的数量，判断能合并多少次
              woodN -= m;  // 合并多少次木棒数就相应减少多少次
          }else{
              woodN -= Math.floor(woodN / 2);
          }
          num++;
      }
      console.log(num);
  }
  ```